{"version":3,"sources":["node_modules/browser-pack/_prelude.js","app/js/DriveTreeCreator.js","app/js/index.entry.js","node_modules/@babel/runtime/helpers/asyncToGenerator.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/regenerator/index.js","node_modules/regenerator-runtime/runtime.js"],"names":[],"mappings":"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OAAO,CAAC,GAAR,CAAY,OAAZ;AACD,WAFD,EAlByD;;AAsBzD,WAAC,CAAC,CAAC,QAAF,EAtBwD,sEAsBlC,CAAC,CAAC,MAAF,EAtBkC;;AAwBzD,UAAA,OAAO,CAAC,IAAR,CAAa,OAAb,EAxByD;AAyBxC,YAAA,CAAC,CAAC,KAAF,EAzBwC,UAyBrD,IAzBqD;AA0BzD,UAAA,OAAO,CAAC,OAAR,CAAgB,OAAhB;AACA,UAAA,OAAO,CAAC,GAAR,CAAY,IAAZ,EA3ByD,yDAA3D;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\r\n * --------------------------------------------------------------------------\r\n * DriveTreeCreator.js\r\n * @description pretty easy way to create a ton of folder tree from google drive\r\n * @version 0.0.1\r\n * @license WTFPL\r\n * @author BUFF\r\n * --------------------------------------------------------------------------\r\n */\r\nclass DriveTreeCreator {\r\n  constructor (options) {\r\n    //  default options\r\n    this.options = {\r\n      googleAPI: {\r\n        clientId: \"\",\r\n        apiKey: \"\",\r\n        /**\r\n         which folder do you want to get from?\r\n         accept multiple folder Id\r\n         use , to segmentation\r\n         like\r\n         folderIdTest,folderIdTest2,folderIdTest3\r\n         */\r\n        folderId: \"\",\r\n        /*\r\n        the owner of the google folder\r\n        that's a point of DriveTreeCreator working\r\n        as we know , we cant get children folder or grandson folder\r\n        by google drive api, cuz google not provide it\r\n        but interestingly we can use the owner parameter to replace it!\r\n        */\r\n        owner: \"\",\r\n      },\r\n      scope: 'https://www.googleapis.com/auth/drive',\r\n      discovery_docs: [\"https://script.googleapis.com/$discovery/rest?version=v1\"],\r\n      //  list files except trash file\r\n      inTrash: false,\r\n      //  google drive api list parameter ---- files\r\n      //  https://developers.google.com/drive/api/v3/search-files\r\n      files: `id,name,size,createdTime,webContentLink,webViewLink,mimeType,parents,fileExtension`,\r\n      //  google drive api list parameter\r\n      //  https://developers.google.com/drive/api/v3/reference/files/list\r\n      includeTeamDriveItems: false,\r\n      //  sort file from dir view, accept a fn\r\n      sort: null\r\n    }\r\n    this.options = Object.assign(this.options, options)\r\n    \r\n  }\r\n  \r\n  /**\r\n   * a method from initialization google api environment\r\n   * which mean u should call it after new DriveTreeCreator,immediately\r\n   * and every method calling should after init finish\r\n   * @returns {Promise<any>} when environment has been ready for roll\r\n   */\r\n  init () {\r\n    return new Promise(async res => {\r\n      if (window.gapi) {\r\n        if (!window.gapi.client.script || !window.gapi.client.drive) {\r\n          throw new Error('make sure gapi.client.script or gapi.client.drive has been set up, use gapi.load pls');\r\n        } else {\r\n          this._event()\r\n          res()\r\n        }\r\n      } else {\r\n        await this._loadGApi()\r\n        this._event()\r\n        res()\r\n      }\r\n    })\r\n  }\r\n  \r\n  /**\r\n   * subscribe event\r\n   *\r\n   * signInStateChange\r\n   * loadProcess\r\n   *\r\n   * @private\r\n   */\r\n  _event () {\r\n    //  user sign in state change\r\n    window.gapi.auth2.getAuthInstance().isSignedIn.listen(isSignedIn => this._emitEvent('signInStateChange', {state: isSignedIn}))\r\n  }\r\n  \r\n  /**\r\n   * manually emit an event\r\n   * @private\r\n   */\r\n  _emitEvent (eventName, payload = {}) {\r\n    if (!this.handlers) {\r\n      return\r\n    }\r\n    \r\n    let handlers = this.handlers[eventName]\r\n    handlers && handlers.forEach(handler => handler(payload))\r\n  }\r\n  \r\n  /**\r\n   * get pop page to sign in google account\r\n   */\r\n  signIn () {\r\n    return window.gapi.auth2.getAuthInstance().signIn({prompt: 'select_account'})\r\n  }\r\n  \r\n  signOut () {\r\n    return gapi.auth2.getAuthInstance().signOut()\r\n  }\r\n  \r\n  /**\r\n   * start to create tree view\r\n   * @returns {Promise<any>}\r\n   * steps:\r\n   * 1. get all files by owners user\r\n   * 2. createTree by files\r\n   * 3. sort\r\n   * 4. return specific folder from folderId parameter\r\n   */\r\n  start () {\r\n    if (!this.isSignIn()) {\r\n      throw new Error('cant run start method, should sign-in first')\r\n    }\r\n    \r\n    return new Promise(async res => {\r\n      //  step 1\r\n      //  get all files by owners user\r\n      this._emitEvent('loadProcess', {process: 'start', count: 0})\r\n      let files = []\r\n      if (window.location.href.indexOf('localhost') && false) {\r\n        let cache = window.localStorage.getItem('filesCache')\r\n        if (window.localStorage.getItem('filesCache')) {\r\n          files = JSON.parse(cache)\r\n        } else {\r\n          files = await this._getAllFilesUnderRootFolder()\r\n          window.localStorage.setItem('filesCache', JSON.stringify(files))\r\n        }\r\n      } else {\r\n        files = await this._getAllFilesUnderRootFolder()\r\n      }\r\n      \r\n      //   step 2\r\n      //  createTree by files\r\n      let dir = this._createTree(files)\r\n      \r\n      //  step 3\r\n      //  sort\r\n      if (!~this.options.files.indexOf('name')) {\r\n        throw new Error('should include `name` field in options.files')\r\n      }\r\n      \r\n      Object.keys(dir).map(key => {\r\n        this._sort(dir[key])\r\n      })\r\n      \r\n      //  step 4\r\n      //  return specific folder from folderId parameter\r\n      dir = Object.values(dir)\r\n      \r\n      \r\n      let result = []\r\n      this.options.googleAPI.folderId.split(',').map(id => result.push(this._returnSpecificFolder(dir, id)))\r\n      res(result)\r\n    })\r\n  }\r\n  \r\n  /**\r\n   * find specific folder from dir\r\n   * @private\r\n   */\r\n  _returnSpecificFolder (dir, id) {\r\n    for (let i = 0 ; i < dir.length ; i++) {\r\n      if (dir[i].id === id) {\r\n        return dir[i]\r\n      } else {\r\n        if (dir[i].children) {\r\n          let res = this._returnSpecificFolder(dir[i].children, id)\r\n          if (res) {\r\n            return res\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  _sort (dir) {\r\n    if (dir.children && dir.children.length > 0) {\r\n      //  sort\r\n      dir.children.sort((a, b) => this.options.sort ? this.options.sort(a, b) : a.name.localeCompare(b.name, 'zh'))\r\n      dir.children.map(item => this._sort(item))\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * core !!!!!!!!!!!!!!!!!!!!!!!!!\r\n   * generator three view by parents from each file\r\n   * @param files\r\n   * @private\r\n   */\r\n  _createTree (files) {\r\n    let relationKeyPath = {}\r\n    let newData = {}\r\n    \r\n    files.map(item => newData[item.id] = item)\r\n    files = newData\r\n    newData = null\r\n    \r\n    //  core\r\n    Object.keys(files).map(key => {\r\n      if (files[key].parents) {\r\n        let parentId = files[key].parents[0]\r\n        let item = files[key]\r\n        \r\n        if (files[parentId]) {\r\n          if (files[parentId].children) {\r\n            files[parentId].children.push(item)\r\n          } else {\r\n            files[parentId].children = [item]\r\n          }\r\n          \r\n          relationKeyPath[key] = [parentId]\r\n          delete files[key]\r\n        } else {\r\n          if (relationKeyPath[parentId]) {\r\n            relationKeyPath[parentId] = this.__findKeyPath(parentId, relationKeyPath)\r\n            let parentObj = null\r\n            relationKeyPath[parentId].map(_parentId => {\r\n              if (Array.isArray(parentObj)) {\r\n                parentObj.map((__parentItem, __key) => {\r\n                  if (__parentItem.id === _parentId) {\r\n                    parentObj = parentObj[__key].children\r\n                  }\r\n                })\r\n              } else {\r\n                parentObj = files[_parentId].children\r\n              }\r\n            })\r\n            \r\n            parentObj.map(___item => {\r\n              if (___item.id === parentId) {\r\n                if (___item.children) {\r\n                  ___item.children.push(item)\r\n                } else {\r\n                  ___item.children = [item]\r\n                }\r\n              }\r\n            });\r\n            relationKeyPath[key] = [parentId]\r\n            delete files[key]\r\n          }\r\n        }\r\n      }\r\n    })\r\n    \r\n    return files\r\n  }\r\n  \r\n  __findKeyPath (key, relationPath, arr = []) {\r\n    if (relationPath[key]) {\r\n      arr = relationPath[key].concat(arr)\r\n      return this.__findKeyPath(arr[0], relationPath, arr)\r\n    } else {\r\n      return arr\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * get all files by owners user\r\n   * @param nextPageToken\r\n   * @param data\r\n   * @param count\r\n   * @returns {Promise<any>}\r\n   * @private\r\n   */\r\n  _getAllFilesUnderRootFolder (nextPageToken = '', data = [], count = 1) {\r\n    return new Promise(res => {\r\n      window.gapi.client.drive.files.list({\r\n        pageSize: 1000,\r\n        pageToken: nextPageToken,\r\n        spaces: 'drive',\r\n        q: `'${this.options.googleAPI.owner}' in owners and trashed = ${this.options.inTrash.toString()}`,\r\n        fields: `nextPageToken, files(${this.options.files})`,\r\n        includeTeamDriveItems: this.options.includeTeamDriveItems\r\n      }).then(result => {\r\n        data = data.concat(result.result.files)\r\n        //  emit event\r\n        this._emitEvent('loadProcess', {process: count, count: result.result.files.length})\r\n        count++\r\n        if (result.result.nextPageToken) {\r\n          res(this._getAllFilesUnderRootFolder(result.result.nextPageToken, data, count))\r\n        } else {\r\n          this._emitEvent('loadProcess', {process: 'down', count: data.length})\r\n          res(data)\r\n        }\r\n      });\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * check user Sign In state\r\n   */\r\n  isSignIn () {\r\n    return window.gapi.auth2.getAuthInstance().isSignedIn.get()\r\n  }\r\n  \r\n  /**\r\n   * Attach a handler function for an event.\r\n   * @param eventName\r\n   * @param handler\r\n   */\r\n  on (eventName, handler) {\r\n    let self = this\r\n    if (!this.handlers) {\r\n      this.handlers = {}\r\n    }\r\n    \r\n    let handlers = this.handlers[eventName];\r\n    \r\n    if (!handlers) {\r\n      handlers = this.handlers[eventName] = []\r\n    }\r\n    \r\n    handlers.push(handler)\r\n    \r\n    // Return an event descriptor\r\n    return {\r\n      name: eventName,\r\n      callback: handler,\r\n      un: (e, fn) => self.un(e, fn)\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Remove an event handler.\r\n   * @param eventName\r\n   * @param handle\r\n   */\r\n  un (eventName, handle) {\r\n    if (!this.handlers) {\r\n      return\r\n    }\r\n    \r\n    let handlers = this.handlers[eventName]\r\n    let i\r\n    \r\n    if (handlers) {\r\n      if (handle) {\r\n        for (i = handlers.length - 1 ; i >= 0 ; i--) {\r\n          handlers[i] == handle && handlers.splice(i, 1)\r\n        }\r\n      } else {\r\n        handlers.length = 0\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * get user information from current sign in\r\n   */\r\n  getCurrentUser () {\r\n    let userProfile = window.gapi.auth2.getAuthInstance().currentUser.get().getBasicProfile()\r\n    return userProfile ? {\r\n      email: userProfile.getEmail(),\r\n      name: userProfile.getName(),\r\n      image: userProfile.getImageUrl(),\r\n      id: userProfile.getId(),\r\n      token: window.gapi.auth.getToken().access_token\r\n    } : {}\r\n  }\r\n  \r\n  /**\r\n   * load google sdk\r\n   * @private\r\n   */\r\n  _loadGApi () {\r\n    return new Promise(async res => {\r\n      await this._loadScript('https://apis.google.com/js/api.js')\r\n      window.gapi.load('client:auth2', () => {\r\n        window.gapi.client.load('drive', 'v3', async () => {\r\n          await window.gapi.client.init({\r\n            apiKey: this.options.googleAPI.apiKey,\r\n            clientId: this.options.googleAPI.clientId,\r\n            discoveryDocs: this.options.discovery_docs,\r\n            scope: this.options.scope\r\n          })\r\n          res()\r\n        })\r\n      })\r\n    })\r\n  }\r\n  \r\n  /**\r\n   * same as $.loadScript()\r\n   * @param src\r\n   * @returns {Promise<any>}\r\n   * @private\r\n   */\r\n  _loadScript (src) {\r\n    return new Promise((res, rej) => {\r\n      let script = document.createElement('script')\r\n      script.async = true\r\n      script.onerror = () => rej()\r\n      script.onload = () => res(src)\r\n      script.src = src\r\n      document.querySelector('body').appendChild(script)\r\n    })\r\n  }\r\n  \r\n}\r\n\r\nexport default DriveTreeCreator\r\n","import DriveTreeCreator from './DriveTreeCreator'\r\n\r\ndocument.querySelector('#start').addEventListener('click', async () => {\r\n  let D = new DriveTreeCreator({\r\n    googleAPI: {\r\n      clientId: clientId.value,\r\n      apiKey: apiKey.value,\r\n      folderId: folderId.value,\r\n      owner: owner.value\r\n    }\r\n  })\r\n  \r\n  await D.init()\r\n  \r\n  //  loading state change\r\n  D.on('signInStateChange', payload => {\r\n    console.log(payload)\r\n  })\r\n  \r\n  //  loading process\r\n  D.on('loadProcess', payload => {\r\n    console.log(payload)\r\n  })\r\n  \r\n  !D.isSignIn() && await D.signIn()\r\n  \r\n  console.time('start')\r\n  let data = await D.start()\r\n  console.timeEnd('start')\r\n  console.log(data)\r\n})\r\n\r\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvanMvRHJpdmVUcmVlQ3JlYXRvci5qcyIsImFwcC9qcy9pbmRleC5lbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs0aUJDQUE7Ozs7Ozs7OztBQVNNLGdCO0FBQ0osNEJBQWEsT0FBYixFQUFzQjtBQUNwQjtBQUNBLFNBQUssT0FBTCxHQUFlO0FBQ2IsTUFBQSxTQUFTLEVBQUU7QUFDVCxRQUFBLFFBQVEsRUFBRSxFQUREO0FBRVQsUUFBQSxNQUFNLEVBQUUsRUFGQztBQUdUOzs7Ozs7O0FBT0EsUUFBQSxRQUFRLEVBQUUsRUFWRDtBQVdUOzs7Ozs7O0FBT0EsUUFBQSxLQUFLLEVBQUUsRUFsQkUsRUFERTs7QUFxQmIsTUFBQSxLQUFLLEVBQUUsdUNBckJNO0FBc0JiLE1BQUEsY0FBYyxFQUFFLENBQUMsMERBQUQsQ0F0Qkg7QUF1QmI7QUFDQSxNQUFBLE9BQU8sRUFBRSxLQXhCSTtBQXlCYjtBQUNBO0FBQ0EsTUFBQSxLQUFLLHNGQTNCUTtBQTRCYjtBQUNBO0FBQ0EsTUFBQSxxQkFBcUIsRUFBRSxLQTlCVjtBQStCYjtBQUNBLE1BQUEsSUFBSSxFQUFFLElBaENPLEVBQWY7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLyoqXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIERyaXZlVHJlZUNyZWF0b3IuanNcclxuICogQGRlc2NyaXB0aW9uIHByZXR0eSBlYXN5IHdheSB0byBjcmVhdGUgYSB0b24gb2YgZm9sZGVyIHRyZWUgZnJvbSBnb29nbGUgZHJpdmVcclxuICogQHZlcnNpb24gMC4wLjFcclxuICogQGxpY2Vuc2UgV1RGUExcclxuICogQGF1dGhvciBCVUZGXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqL1xyXG5jbGFzcyBEcml2ZVRyZWVDcmVhdG9yIHtcclxuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xyXG4gICAgLy8gIGRlZmF1bHQgb3B0aW9uc1xyXG4gICAgdGhpcy5vcHRpb25zID0ge1xyXG4gICAgICBnb29nbGVBUEk6IHtcclxuICAgICAgICBjbGllbnRJZDogXCJcIixcclxuICAgICAgICBhcGlLZXk6IFwiXCIsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgIHdoaWNoIGZvbGRlciBkbyB5b3Ugd2FudCB0byBnZXQgZnJvbT9cclxuICAgICAgICAgYWNjZXB0IG11bHRpcGxlIGZvbGRlciBJZFxyXG4gICAgICAgICB1c2UgLCB0byBzZWdtZW50YXRpb25cclxuICAgICAgICAgbGlrZVxyXG4gICAgICAgICBmb2xkZXJJZFRlc3QsZm9sZGVySWRUZXN0Mixmb2xkZXJJZFRlc3QzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZm9sZGVySWQ6IFwiXCIsXHJcbiAgICAgICAgLypcclxuICAgICAgICB0aGUgb3duZXIgb2YgdGhlIGdvb2dsZSBmb2xkZXJcclxuICAgICAgICB0aGF0J3MgYSBwb2ludCBvZiBEcml2ZVRyZWVDcmVhdG9yIHdvcmtpbmdcclxuICAgICAgICBhcyB3ZSBrbm93ICwgd2UgY2FudCBnZXQgY2hpbGRyZW4gZm9sZGVyIG9yIGdyYW5kc29uIGZvbGRlclxyXG4gICAgICAgIGJ5IGdvb2dsZSBkcml2ZSBhcGksIGN1eiBnb29nbGUgbm90IHByb3ZpZGUgaXRcclxuICAgICAgICBidXQgaW50ZXJlc3RpbmdseSB3ZSBjYW4gdXNlIHRoZSBvd25lciBwYXJhbWV0ZXIgdG8gcmVwbGFjZSBpdCFcclxuICAgICAgICAqL1xyXG4gICAgICAgIG93bmVyOiBcIlwiLFxyXG4gICAgICB9LFxyXG4gICAgICBzY29wZTogJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZHJpdmUnLFxyXG4gICAgICBkaXNjb3ZlcnlfZG9jczogW1wiaHR0cHM6Ly9zY3JpcHQuZ29vZ2xlYXBpcy5jb20vJGRpc2NvdmVyeS9yZXN0P3ZlcnNpb249djFcIl0sXHJcbiAgICAgIC8vICBsaXN0IGZpbGVzIGV4Y2VwdCB0cmFzaCBmaWxlXHJcbiAgICAgIGluVHJhc2g6IGZhbHNlLFxyXG4gICAgICAvLyAgZ29vZ2xlIGRyaXZlIGFwaSBsaXN0IHBhcmFtZXRlciAtLS0tIGZpbGVzXHJcbiAgICAgIC8vICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9kcml2ZS9hcGkvdjMvc2VhcmNoLWZpbGVzXHJcbiAgICAgIGZpbGVzOiBgaWQsbmFtZSxzaXplLGNyZWF0ZWRUaW1lLHdlYkNvbnRlbnRMaW5rLHdlYlZpZXdMaW5rLG1pbWVUeXBlLHBhcmVudHMsZmlsZUV4dGVuc2lvbmAsXHJcbiAgICAgIC8vICBnb29nbGUgZHJpdmUgYXBpIGxpc3QgcGFyYW1ldGVyXHJcbiAgICAgIC8vICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9kcml2ZS9hcGkvdjMvcmVmZXJlbmNlL2ZpbGVzL2xpc3RcclxuICAgICAgaW5jbHVkZVRlYW1Ecml2ZUl0ZW1zOiBmYWxzZSxcclxuICAgICAgLy8gIHNvcnQgZmlsZSBmcm9tIGRpciB2aWV3LCBhY2NlcHQgYSBmblxyXG4gICAgICBzb3J0OiBudWxsXHJcbiAgICB9XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucylcclxuICAgIFxyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBhIG1ldGhvZCBmcm9tIGluaXRpYWxpemF0aW9uIGdvb2dsZSBhcGkgZW52aXJvbm1lbnRcclxuICAgKiB3aGljaCBtZWFuIHUgc2hvdWxkIGNhbGwgaXQgYWZ0ZXIgbmV3IERyaXZlVHJlZUNyZWF0b3IsaW1tZWRpYXRlbHlcclxuICAgKiBhbmQgZXZlcnkgbWV0aG9kIGNhbGxpbmcgc2hvdWxkIGFmdGVyIGluaXQgZmluaXNoXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gd2hlbiBlbnZpcm9ubWVudCBoYXMgYmVlbiByZWFkeSBmb3Igcm9sbFxyXG4gICAqL1xyXG4gIGluaXQgKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIHJlcyA9PiB7XHJcbiAgICAgIGlmICh3aW5kb3cuZ2FwaSkge1xyXG4gICAgICAgIGlmICghd2luZG93LmdhcGkuY2xpZW50LnNjcmlwdCB8fCAhd2luZG93LmdhcGkuY2xpZW50LmRyaXZlKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ha2Ugc3VyZSBnYXBpLmNsaWVudC5zY3JpcHQgb3IgZ2FwaS5jbGllbnQuZHJpdmUgaGFzIGJlZW4gc2V0IHVwLCB1c2UgZ2FwaS5sb2FkIHBscycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9ldmVudCgpXHJcbiAgICAgICAgICByZXMoKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhd2FpdCB0aGlzLl9sb2FkR0FwaSgpXHJcbiAgICAgICAgdGhpcy5fZXZlbnQoKVxyXG4gICAgICAgIHJlcygpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIHN1YnNjcmliZSBldmVudFxyXG4gICAqXHJcbiAgICogc2lnbkluU3RhdGVDaGFuZ2VcclxuICAgKiBsb2FkUHJvY2Vzc1xyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfZXZlbnQgKCkge1xyXG4gICAgLy8gIHVzZXIgc2lnbiBpbiBzdGF0ZSBjaGFuZ2VcclxuICAgIHdpbmRvdy5nYXBpLmF1dGgyLmdldEF1dGhJbnN0YW5jZSgpLmlzU2lnbmVkSW4ubGlzdGVuKGlzU2lnbmVkSW4gPT4gdGhpcy5fZW1pdEV2ZW50KCdzaWduSW5TdGF0ZUNoYW5nZScsIHtzdGF0ZTogaXNTaWduZWRJbn0pKVxyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBtYW51YWxseSBlbWl0IGFuIGV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfZW1pdEV2ZW50IChldmVudE5hbWUsIHBheWxvYWQgPSB7fSkge1xyXG4gICAgaWYgKCF0aGlzLmhhbmRsZXJzKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBsZXQgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV1cclxuICAgIGhhbmRsZXJzICYmIGhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKHBheWxvYWQpKVxyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBnZXQgcG9wIHBhZ2UgdG8gc2lnbiBpbiBnb29nbGUgYWNjb3VudFxyXG4gICAqL1xyXG4gIHNpZ25JbiAoKSB7XHJcbiAgICByZXR1cm4gd2luZG93LmdhcGkuYXV0aDIuZ2V0QXV0aEluc3RhbmNlKCkuc2lnbkluKHtwcm9tcHQ6ICdzZWxlY3RfYWNjb3VudCd9KVxyXG4gIH1cclxuICBcclxuICBzaWduT3V0ICgpIHtcclxuICAgIHJldHVybiBnYXBpLmF1dGgyLmdldEF1dGhJbnN0YW5jZSgpLnNpZ25PdXQoKVxyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBzdGFydCB0byBjcmVhdGUgdHJlZSB2aWV3XHJcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cclxuICAgKiBzdGVwczpcclxuICAgKiAxLiBnZXQgYWxsIGZpbGVzIGJ5IG93bmVycyB1c2VyXHJcbiAgICogMi4gY3JlYXRlVHJlZSBieSBmaWxlc1xyXG4gICAqIDMuIHNvcnRcclxuICAgKiA0LiByZXR1cm4gc3BlY2lmaWMgZm9sZGVyIGZyb20gZm9sZGVySWQgcGFyYW1ldGVyXHJcbiAgICovXHJcbiAgc3RhcnQgKCkge1xyXG4gICAgaWYgKCF0aGlzLmlzU2lnbkluKCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW50IHJ1biBzdGFydCBtZXRob2QsIHNob3VsZCBzaWduLWluIGZpcnN0JylcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIHJlcyA9PiB7XHJcbiAgICAgIC8vICBzdGVwIDFcclxuICAgICAgLy8gIGdldCBhbGwgZmlsZXMgYnkgb3duZXJzIHVzZXJcclxuICAgICAgdGhpcy5fZW1pdEV2ZW50KCdsb2FkUHJvY2VzcycsIHtwcm9jZXNzOiAnc3RhcnQnLCBjb3VudDogMH0pXHJcbiAgICAgIGxldCBmaWxlcyA9IFtdXHJcbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCdsb2NhbGhvc3QnKSAmJiBmYWxzZSkge1xyXG4gICAgICAgIGxldCBjYWNoZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZmlsZXNDYWNoZScpXHJcbiAgICAgICAgaWYgKHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZmlsZXNDYWNoZScpKSB7XHJcbiAgICAgICAgICBmaWxlcyA9IEpTT04ucGFyc2UoY2FjaGUpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZpbGVzID0gYXdhaXQgdGhpcy5fZ2V0QWxsRmlsZXNVbmRlclJvb3RGb2xkZXIoKVxyXG4gICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdmaWxlc0NhY2hlJywgSlNPTi5zdHJpbmdpZnkoZmlsZXMpKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmaWxlcyA9IGF3YWl0IHRoaXMuX2dldEFsbEZpbGVzVW5kZXJSb290Rm9sZGVyKClcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gICBzdGVwIDJcclxuICAgICAgLy8gIGNyZWF0ZVRyZWUgYnkgZmlsZXNcclxuICAgICAgbGV0IGRpciA9IHRoaXMuX2NyZWF0ZVRyZWUoZmlsZXMpXHJcbiAgICAgIFxyXG4gICAgICAvLyAgc3RlcCAzXHJcbiAgICAgIC8vICBzb3J0XHJcbiAgICAgIGlmICghfnRoaXMub3B0aW9ucy5maWxlcy5pbmRleE9mKCduYW1lJykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCBpbmNsdWRlIGBuYW1lYCBmaWVsZCBpbiBvcHRpb25zLmZpbGVzJylcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgT2JqZWN0LmtleXMoZGlyKS5tYXAoa2V5ID0+IHtcclxuICAgICAgICB0aGlzLl9zb3J0KGRpcltrZXldKVxyXG4gICAgICB9KVxyXG4gICAgICBcclxuICAgICAgLy8gIHN0ZXAgNFxyXG4gICAgICAvLyAgcmV0dXJuIHNwZWNpZmljIGZvbGRlciBmcm9tIGZvbGRlcklkIHBhcmFtZXRlclxyXG4gICAgICBkaXIgPSBPYmplY3QudmFsdWVzKGRpcilcclxuICAgICAgXHJcbiAgICAgIFxyXG4gICAgICBsZXQgcmVzdWx0ID0gW11cclxuICAgICAgdGhpcy5vcHRpb25zLmdvb2dsZUFQSS5mb2xkZXJJZC5zcGxpdCgnLCcpLm1hcChpZCA9PiByZXN1bHQucHVzaCh0aGlzLl9yZXR1cm5TcGVjaWZpY0ZvbGRlcihkaXIsIGlkKSkpXHJcbiAgICAgIHJlcyhyZXN1bHQpXHJcbiAgICB9KVxyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBmaW5kIHNwZWNpZmljIGZvbGRlciBmcm9tIGRpclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3JldHVyblNwZWNpZmljRm9sZGVyIChkaXIsIGlkKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMCA7IGkgPCBkaXIubGVuZ3RoIDsgaSsrKSB7XHJcbiAgICAgIGlmIChkaXJbaV0uaWQgPT09IGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpcltpXVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChkaXJbaV0uY2hpbGRyZW4pIHtcclxuICAgICAgICAgIGxldCByZXMgPSB0aGlzLl9yZXR1cm5TcGVjaWZpY0ZvbGRlcihkaXJbaV0uY2hpbGRyZW4sIGlkKVxyXG4gICAgICAgICAgaWYgKHJlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIF9zb3J0IChkaXIpIHtcclxuICAgIGlmIChkaXIuY2hpbGRyZW4gJiYgZGlyLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgLy8gIHNvcnRcclxuICAgICAgZGlyLmNoaWxkcmVuLnNvcnQoKGEsIGIpID0+IHRoaXMub3B0aW9ucy5zb3J0ID8gdGhpcy5vcHRpb25zLnNvcnQoYSwgYikgOiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUsICd6aCcpKVxyXG4gICAgICBkaXIuY2hpbGRyZW4ubWFwKGl0ZW0gPT4gdGhpcy5fc29ydChpdGVtKSlcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogY29yZSAhISEhISEhISEhISEhISEhISEhISEhISEhXHJcbiAgICogZ2VuZXJhdG9yIHRocmVlIHZpZXcgYnkgcGFyZW50cyBmcm9tIGVhY2ggZmlsZVxyXG4gICAqIEBwYXJhbSBmaWxlc1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2NyZWF0ZVRyZWUgKGZpbGVzKSB7XHJcbiAgICBsZXQgcmVsYXRpb25LZXlQYXRoID0ge31cclxuICAgIGxldCBuZXdEYXRhID0ge31cclxuICAgIFxyXG4gICAgZmlsZXMubWFwKGl0ZW0gPT4gbmV3RGF0YVtpdGVtLmlkXSA9IGl0ZW0pXHJcbiAgICBmaWxlcyA9IG5ld0RhdGFcclxuICAgIG5ld0RhdGEgPSBudWxsXHJcbiAgICBcclxuICAgIC8vICBjb3JlXHJcbiAgICBPYmplY3Qua2V5cyhmaWxlcykubWFwKGtleSA9PiB7XHJcbiAgICAgIGlmIChmaWxlc1trZXldLnBhcmVudHMpIHtcclxuICAgICAgICBsZXQgcGFyZW50SWQgPSBmaWxlc1trZXldLnBhcmVudHNbMF1cclxuICAgICAgICBsZXQgaXRlbSA9IGZpbGVzW2tleV1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoZmlsZXNbcGFyZW50SWRdKSB7XHJcbiAgICAgICAgICBpZiAoZmlsZXNbcGFyZW50SWRdLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGZpbGVzW3BhcmVudElkXS5jaGlsZHJlbi5wdXNoKGl0ZW0pXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmaWxlc1twYXJlbnRJZF0uY2hpbGRyZW4gPSBbaXRlbV1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmVsYXRpb25LZXlQYXRoW2tleV0gPSBbcGFyZW50SWRdXHJcbiAgICAgICAgICBkZWxldGUgZmlsZXNba2V5XVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAocmVsYXRpb25LZXlQYXRoW3BhcmVudElkXSkge1xyXG4gICAgICAgICAgICByZWxhdGlvbktleVBhdGhbcGFyZW50SWRdID0gdGhpcy5fX2ZpbmRLZXlQYXRoKHBhcmVudElkLCByZWxhdGlvbktleVBhdGgpXHJcbiAgICAgICAgICAgIGxldCBwYXJlbnRPYmogPSBudWxsXHJcbiAgICAgICAgICAgIHJlbGF0aW9uS2V5UGF0aFtwYXJlbnRJZF0ubWFwKF9wYXJlbnRJZCA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyZW50T2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50T2JqLm1hcCgoX19wYXJlbnRJdGVtLCBfX2tleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoX19wYXJlbnRJdGVtLmlkID09PSBfcGFyZW50SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRPYmogPSBwYXJlbnRPYmpbX19rZXldLmNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudE9iaiA9IGZpbGVzW19wYXJlbnRJZF0uY2hpbGRyZW5cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBwYXJlbnRPYmoubWFwKF9fX2l0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChfX19pdGVtLmlkID09PSBwYXJlbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9fX2l0ZW0uY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgX19faXRlbS5jaGlsZHJlbi5wdXNoKGl0ZW0pXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBfX19pdGVtLmNoaWxkcmVuID0gW2l0ZW1dXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVsYXRpb25LZXlQYXRoW2tleV0gPSBbcGFyZW50SWRdXHJcbiAgICAgICAgICAgIGRlbGV0ZSBmaWxlc1trZXldXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICByZXR1cm4gZmlsZXNcclxuICB9XHJcbiAgXHJcbiAgX19maW5kS2V5UGF0aCAoa2V5LCByZWxhdGlvblBhdGgsIGFyciA9IFtdKSB7XHJcbiAgICBpZiAocmVsYXRpb25QYXRoW2tleV0pIHtcclxuICAgICAgYXJyID0gcmVsYXRpb25QYXRoW2tleV0uY29uY2F0KGFycilcclxuICAgICAgcmV0dXJuIHRoaXMuX19maW5kS2V5UGF0aChhcnJbMF0sIHJlbGF0aW9uUGF0aCwgYXJyKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGFyclxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBnZXQgYWxsIGZpbGVzIGJ5IG93bmVycyB1c2VyXHJcbiAgICogQHBhcmFtIG5leHRQYWdlVG9rZW5cclxuICAgKiBAcGFyYW0gZGF0YVxyXG4gICAqIEBwYXJhbSBjb3VudFxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfZ2V0QWxsRmlsZXNVbmRlclJvb3RGb2xkZXIgKG5leHRQYWdlVG9rZW4gPSAnJywgZGF0YSA9IFtdLCBjb3VudCA9IDEpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXMgPT4ge1xyXG4gICAgICB3aW5kb3cuZ2FwaS5jbGllbnQuZHJpdmUuZmlsZXMubGlzdCh7XHJcbiAgICAgICAgcGFnZVNpemU6IDEwMDAsXHJcbiAgICAgICAgcGFnZVRva2VuOiBuZXh0UGFnZVRva2VuLFxyXG4gICAgICAgIHNwYWNlczogJ2RyaXZlJyxcclxuICAgICAgICBxOiBgJyR7dGhpcy5vcHRpb25zLmdvb2dsZUFQSS5vd25lcn0nIGluIG93bmVycyBhbmQgdHJhc2hlZCA9ICR7dGhpcy5vcHRpb25zLmluVHJhc2gudG9TdHJpbmcoKX1gLFxyXG4gICAgICAgIGZpZWxkczogYG5leHRQYWdlVG9rZW4sIGZpbGVzKCR7dGhpcy5vcHRpb25zLmZpbGVzfSlgLFxyXG4gICAgICAgIGluY2x1ZGVUZWFtRHJpdmVJdGVtczogdGhpcy5vcHRpb25zLmluY2x1ZGVUZWFtRHJpdmVJdGVtc1xyXG4gICAgICB9KS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgZGF0YSA9IGRhdGEuY29uY2F0KHJlc3VsdC5yZXN1bHQuZmlsZXMpXHJcbiAgICAgICAgLy8gIGVtaXQgZXZlbnRcclxuICAgICAgICB0aGlzLl9lbWl0RXZlbnQoJ2xvYWRQcm9jZXNzJywge3Byb2Nlc3M6IGNvdW50LCBjb3VudDogcmVzdWx0LnJlc3VsdC5maWxlcy5sZW5ndGh9KVxyXG4gICAgICAgIGNvdW50KytcclxuICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5uZXh0UGFnZVRva2VuKSB7XHJcbiAgICAgICAgICByZXModGhpcy5fZ2V0QWxsRmlsZXNVbmRlclJvb3RGb2xkZXIocmVzdWx0LnJlc3VsdC5uZXh0UGFnZVRva2VuLCBkYXRhLCBjb3VudCkpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX2VtaXRFdmVudCgnbG9hZFByb2Nlc3MnLCB7cHJvY2VzczogJ2Rvd24nLCBjb3VudDogZGF0YS5sZW5ndGh9KVxyXG4gICAgICAgICAgcmVzKGRhdGEpXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBjaGVjayB1c2VyIFNpZ24gSW4gc3RhdGVcclxuICAgKi9cclxuICBpc1NpZ25JbiAoKSB7XHJcbiAgICByZXR1cm4gd2luZG93LmdhcGkuYXV0aDIuZ2V0QXV0aEluc3RhbmNlKCkuaXNTaWduZWRJbi5nZXQoKVxyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBBdHRhY2ggYSBoYW5kbGVyIGZ1bmN0aW9uIGZvciBhbiBldmVudC5cclxuICAgKiBAcGFyYW0gZXZlbnROYW1lXHJcbiAgICogQHBhcmFtIGhhbmRsZXJcclxuICAgKi9cclxuICBvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICBsZXQgc2VsZiA9IHRoaXNcclxuICAgIGlmICghdGhpcy5oYW5kbGVycykge1xyXG4gICAgICB0aGlzLmhhbmRsZXJzID0ge31cclxuICAgIH1cclxuICAgIFxyXG4gICAgbGV0IGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudE5hbWVdO1xyXG4gICAgXHJcbiAgICBpZiAoIWhhbmRsZXJzKSB7XHJcbiAgICAgIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudE5hbWVdID0gW11cclxuICAgIH1cclxuICAgIFxyXG4gICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKVxyXG4gICAgXHJcbiAgICAvLyBSZXR1cm4gYW4gZXZlbnQgZGVzY3JpcHRvclxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZTogZXZlbnROYW1lLFxyXG4gICAgICBjYWxsYmFjazogaGFuZGxlcixcclxuICAgICAgdW46IChlLCBmbikgPT4gc2VsZi51bihlLCBmbilcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIuXHJcbiAgICogQHBhcmFtIGV2ZW50TmFtZVxyXG4gICAqIEBwYXJhbSBoYW5kbGVcclxuICAgKi9cclxuICB1biAoZXZlbnROYW1lLCBoYW5kbGUpIHtcclxuICAgIGlmICghdGhpcy5oYW5kbGVycykge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIFxyXG4gICAgbGV0IGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudE5hbWVdXHJcbiAgICBsZXQgaVxyXG4gICAgXHJcbiAgICBpZiAoaGFuZGxlcnMpIHtcclxuICAgICAgaWYgKGhhbmRsZSkge1xyXG4gICAgICAgIGZvciAoaSA9IGhhbmRsZXJzLmxlbmd0aCAtIDEgOyBpID49IDAgOyBpLS0pIHtcclxuICAgICAgICAgIGhhbmRsZXJzW2ldID09IGhhbmRsZSAmJiBoYW5kbGVycy5zcGxpY2UoaSwgMSlcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaGFuZGxlcnMubGVuZ3RoID0gMFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIGdldCB1c2VyIGluZm9ybWF0aW9uIGZyb20gY3VycmVudCBzaWduIGluXHJcbiAgICovXHJcbiAgZ2V0Q3VycmVudFVzZXIgKCkge1xyXG4gICAgbGV0IHVzZXJQcm9maWxlID0gd2luZG93LmdhcGkuYXV0aDIuZ2V0QXV0aEluc3RhbmNlKCkuY3VycmVudFVzZXIuZ2V0KCkuZ2V0QmFzaWNQcm9maWxlKClcclxuICAgIHJldHVybiB1c2VyUHJvZmlsZSA/IHtcclxuICAgICAgZW1haWw6IHVzZXJQcm9maWxlLmdldEVtYWlsKCksXHJcbiAgICAgIG5hbWU6IHVzZXJQcm9maWxlLmdldE5hbWUoKSxcclxuICAgICAgaW1hZ2U6IHVzZXJQcm9maWxlLmdldEltYWdlVXJsKCksXHJcbiAgICAgIGlkOiB1c2VyUHJvZmlsZS5nZXRJZCgpLFxyXG4gICAgICB0b2tlbjogd2luZG93LmdhcGkuYXV0aC5nZXRUb2tlbigpLmFjY2Vzc190b2tlblxyXG4gICAgfSA6IHt9XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIGxvYWQgZ29vZ2xlIHNka1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2xvYWRHQXBpICgpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyByZXMgPT4ge1xyXG4gICAgICBhd2FpdCB0aGlzLl9sb2FkU2NyaXB0KCdodHRwczovL2FwaXMuZ29vZ2xlLmNvbS9qcy9hcGkuanMnKVxyXG4gICAgICB3aW5kb3cuZ2FwaS5sb2FkKCdjbGllbnQ6YXV0aDInLCAoKSA9PiB7XHJcbiAgICAgICAgd2luZG93LmdhcGkuY2xpZW50LmxvYWQoJ2RyaXZlJywgJ3YzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmluaXQoe1xyXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMub3B0aW9ucy5nb29nbGVBUEkuYXBpS2V5LFxyXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5vcHRpb25zLmdvb2dsZUFQSS5jbGllbnRJZCxcclxuICAgICAgICAgICAgZGlzY292ZXJ5RG9jczogdGhpcy5vcHRpb25zLmRpc2NvdmVyeV9kb2NzLFxyXG4gICAgICAgICAgICBzY29wZTogdGhpcy5vcHRpb25zLnNjb3BlXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgcmVzKClcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogc2FtZSBhcyAkLmxvYWRTY3JpcHQoKVxyXG4gICAqIEBwYXJhbSBzcmNcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2xvYWRTY3JpcHQgKHNyYykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xyXG4gICAgICBsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcclxuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZVxyXG4gICAgICBzY3JpcHQub25lcnJvciA9ICgpID0+IHJlaigpXHJcbiAgICAgIHNjcmlwdC5vbmxvYWQgPSAoKSA9PiByZXMoc3JjKVxyXG4gICAgICBzY3JpcHQuc3JjID0gc3JjXHJcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKS5hcHBlbmRDaGlsZChzY3JpcHQpXHJcbiAgICB9KVxyXG4gIH1cclxuICBcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRHJpdmVUcmVlQ3JlYXRvclxyXG4iLCJpbXBvcnQgRHJpdmVUcmVlQ3JlYXRvciBmcm9tICcuL0RyaXZlVHJlZUNyZWF0b3InXHJcblxyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3RhcnQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICBsZXQgRCA9IG5ldyBEcml2ZVRyZWVDcmVhdG9yKHtcclxuICAgIGdvb2dsZUFQSToge1xyXG4gICAgICBjbGllbnRJZDogY2xpZW50SWQudmFsdWUsXHJcbiAgICAgIGFwaUtleTogYXBpS2V5LnZhbHVlLFxyXG4gICAgICBmb2xkZXJJZDogZm9sZGVySWQudmFsdWUsXHJcbiAgICAgIG93bmVyOiBvd25lci52YWx1ZVxyXG4gICAgfVxyXG4gIH0pXHJcbiAgXHJcbiAgYXdhaXQgRC5pbml0KClcclxuICBcclxuICAvLyAgbG9hZGluZyBzdGF0ZSBjaGFuZ2VcclxuICBELm9uKCdzaWduSW5TdGF0ZUNoYW5nZScsIHBheWxvYWQgPT4ge1xyXG4gICAgY29uc29sZS5sb2cocGF5bG9hZClcclxuICB9KVxyXG4gIFxyXG4gIC8vICBsb2FkaW5nIHByb2Nlc3NcclxuICBELm9uKCdsb2FkUHJvY2VzcycsIHBheWxvYWQgPT4ge1xyXG4gICAgY29uc29sZS5sb2cocGF5bG9hZClcclxuICB9KVxyXG4gIFxyXG4gICFELmlzU2lnbkluKCkgJiYgYXdhaXQgRC5zaWduSW4oKVxyXG4gIFxyXG4gIGNvbnNvbGUudGltZSgnc3RhcnQnKVxyXG4gIGxldCBkYXRhID0gYXdhaXQgRC5zdGFydCgpXHJcbiAgY29uc29sZS50aW1lRW5kKCdzdGFydCcpXHJcbiAgY29uc29sZS5sb2coZGF0YSlcclxufSlcclxuXHJcbiIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iXX0="}